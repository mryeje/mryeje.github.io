<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netflix Viewing History Rater</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        .container {
            width: 90%;
            max-width: 900px;
            margin: 20px auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        h1 {
            color: #E50914;
            text-align: center;
        }
        p {
            text-align: center;
        }
        .file-input-container {
            text-align: center;
            margin-bottom: 20px;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 40px 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 90%;
            min-height: 250px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .title-name {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .rating-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        .rating-button {
            padding: 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .rating-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .rating-button.hated { background-color: #d9534f; }
        .rating-button.sucked { background-color: #f0ad4e; }
        .rating-button.ok { background-color: #5bc0de; }
        .rating-button.good { background-color: #5cb85c; }
        .rating-button.amazing { background-color: #0275d8; }
        .rating-button.dont-remember { background-color: #6c757d; }
        .results-section {
            margin-top: 40px;
            border-top: 2px solid #ccc;
            padding-top: 20px;
            display: none;
        }
        #results-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        #results-table th, #results-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        #results-table th {
            background-color: #f2f2f2;
        }
        .download-button {
            padding: 12px 24px;
            background-color: #E50914;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            display: block;
            margin: 20px auto;
        }
        .prompt-textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
        }
        .paste-bin-textarea {
            width: 100%;
            min-height: 400px;
            padding: 20px;
            box-sizing: border-box;
            border: 2px dashed #007bff;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            background-color: #f8f9fa;
            transition: border-color 0.3s ease, background-color 0.3s ease;
        }
        .paste-bin-textarea:focus {
            border-color: #0056b3;
            background-color: #ffffff;
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }
        .paste-bin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .paste-bin-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }
        .character-count {
            font-size: 0.9em;
            color: #666;
            font-family: monospace;
        }
        .copy-button {
            padding: 12px 24px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px auto;
            display: block;
        }
        .copy-button:hover {
            background-color: #218838;
        }
        .enough-button {
            padding: 12px 24px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px;
            font-size: 0.9em;
        }
        .enough-button:hover {
            background-color: #5a6268;
        }
        .modal-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .progress-counter {
            font-size: 0.9em;
            color: #666;
        }
        /* Mobile responsiveness */
        @media (max-width: 600px) {
            .container {
                width: 95%;
            }
            .modal-content {
                padding: 20px;
            }
            .rating-buttons {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Netflix Viewing History Rater</h1>
    <div class="file-input-container">
        <p>Upload your Netflix viewing history CSV file to rate your shows and movies, or upload existing ratings files.</p>
        <input type="file" id="csvFile" accept=".csv,.txt" />
        <p style="margin-top: 10px;"><em>Supports: Netflix CSV files, TXT files with ratings, or CSV exports from previous sessions</em></p>
    </div>

    <div class="results-section" id="text-converter-section" style="display: none;">
        <div class="paste-bin-header">
            <h2 class="paste-bin-title">üìã Text to CSV Converter - Paste Bin</h2>
            <div class="character-count" id="char-counter">0 characters</div>
        </div>
        <p>Paste your ratings in the format below. This large text area can handle extensive rating lists:</p>
        <div style="margin-bottom: 15px;">
            <button class="copy-button" style="background-color: #17a2b8; margin-right: 10px;" onclick="pasteFromClipboard()">üìã Paste from Clipboard</button>
            <button class="copy-button" style="background-color: #ffc107; color: #000; margin-right: 10px;" onclick="clearTextInput()">üóëÔ∏è Clear All</button>
            <button class="copy-button" style="background-color: #28a745;" onclick="autoFormatText()">‚ú® Auto-Format</button>
        </div>
        <textarea 
            class="paste-bin-textarea" 
            id="text-input" 
            placeholder='üìù Paste your ratings here in any of these formats:

Format 1 (Preferred):
- **Title:** "Movie Name"
**Rating:** 5
- **Title:** "Another Movie"
**Rating:** 3

Format 2 (Also works):
Movie Name: 5
Another Movie: 3

Format 3 (Basic):
Movie Name,5
Another Movie,3

üí° Tip: You can paste large amounts of text - this paste bin can handle thousands of titles!'
            oninput="updateCharacterCount()"
            onpaste="setTimeout(updateCharacterCount, 100)"
        ></textarea>
        <div style="margin-top: 15px;">
            <button class="copy-button" onclick="convertTextToCSV()">üìÑ Convert to CSV & Download</button>
            <button class="copy-button" style="background-color: #6c757d; margin-left: 10px;" onclick="toggleConverter()">‚ùå Close Converter</button>
        </div>
    </div>

    <div style="text-align: center; margin: 20px 0;">
        <button class="copy-button" style="background-color: #17a2b8;" onclick="toggleConverter()">Show Text to CSV Converter</button>
    </div>

    <div class="modal-overlay" id="modal-overlay">
        <div class="modal-content">
            <div class="modal-controls">
                <div class="progress-counter" id="progress-counter"></div>
                <button class="enough-button" onclick="finishRating()">That's Enough</button>
            </div>
            <div id="modal-title" class="title-name"></div>
            <div id="modal-buttons" class="rating-buttons">
                <button class="rating-button hated" data-rating="Hated it">Hated it</button>
                <button class="rating-button sucked" data-rating="Kinda Sucked">Kinda Sucked</button>
                <button class="rating-button ok" data-rating="OK">OK</button>
                <button class="rating-button good" data-rating="Good">Good</button>
                <button class="rating-button amazing" data-rating="Amazing">Amazing</button>
                <button class="rating-button dont-remember" data-rating="Don't Remember">Don't Remember</button>
            </div>
        </div>
    </div>

    <div class="results-section" id="results-section">
        <h2>Your Ratings</h2>
        <p>Your ratings have been captured. You can download the results as a CSV file below.</p>
        <table id="results-table">
            <thead>
                <tr>
                    <th>Title</th>
                    <th>Rating</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
        <button class="download-button" onclick="downloadCSV()">Download Ratings CSV</button>
    </div>

    <div class="results-section" id="prompt-section">
        <h2>üéØ Master Entertainment Analysis Prompt</h2>
        <p>Your comprehensive prompt combining all ratings from Netflix history, imported files, and converted text. This master prompt analyzes your complete viewing preferences across all sources.</p>
        <textarea class="prompt-textarea" id="search-prompt" readonly></textarea>
        <button class="copy-button" onclick="copyPrompt()">üìã Copy Master Prompt to Clipboard</button>
    </div>
</div>

<script>
document.getElementById('csvFile').addEventListener('change', handleFileSelect);
document.getElementById('modal-buttons').addEventListener('click', handleRatingClick);

// Load state from localStorage on page load
window.addEventListener('load', loadState);
window.addEventListener('beforeunload', saveState);

const ratings = {};
let uniqueTitles = [];
let currentTitleIndex = 0;

const ratingMap = {
    'Hated it': 1,
    'Kinda Sucked': 2,
    'OK': 3,
    'Good': 4,
    'Amazing': 5,
    "Don't Remember": 'N/A'
};

function saveState() {
    const state = {
        ratings: ratings,
        uniqueTitles: uniqueTitles,
        currentTitleIndex: currentTitleIndex,
        timestamp: Date.now()
    };
    sessionStorage.setItem('netflixRaterState', JSON.stringify(state));
}

function loadState() {
    const savedState = sessionStorage.getItem('netflixRaterState');
    if (savedState) {
        try {
            const state = JSON.parse(savedState);
            // Only restore if it's less than 1 hour old
            if (Date.now() - state.timestamp < 3600000) {
                Object.assign(ratings, state.ratings);
                uniqueTitles = state.uniqueTitles || [];
                currentTitleIndex = state.currentTitleIndex || 0;
                
                if (uniqueTitles.length > 0 && currentTitleIndex < uniqueTitles.length) {
                    if (confirm('It looks like you were in the middle of rating your Netflix titles. Would you like to continue where you left off?')) {
                        document.getElementById('modal-overlay').style.display = 'flex';
                        showCurrentTitle();
                        return;
                    }
                } else if (Object.keys(ratings).length > 0) {
                    // They had completed rating, show results
                    displayResults();
                    generatePrompt();
                }
            }
        } catch (e) {
            console.log('Could not restore previous state');
        }
    }
}

function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file) {
        // Clear previous state when uploading new file
        sessionStorage.removeItem('netflixRaterState');
        Object.keys(ratings).forEach(key => delete ratings[key]);
        uniqueTitles = [];
        currentTitleIndex = 0;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            if (file.name.toLowerCase().endsWith('.txt')) {
                processTXT(e.target.result);
            } else if (file.name.toLowerCase().endsWith('.csv')) {
                // Check if it's a ratings CSV (has Title,Rating format) or Netflix history CSV
                const content = e.target.result;
                const lines = content.split('\n');
                if (lines[0] && lines[0].toLowerCase().includes('title') && lines[0].toLowerCase().includes('rating')) {
                    processRatingsCSV(content);
                } else {
                    processNetflixCSV(content);
                }
            }
        };
        reader.readAsText(file);
    }
}

function processTXT(text) {
    const lines = text.split('\n');
    const extractedRatings = {};
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Look for title line
        if (line.includes('**Title:**')) {
            const titleMatch = line.match(/\*\*Title:\*\*\s*"([^"]+)"/);
            if (titleMatch && i + 1 < lines.length) {
                const title = titleMatch[1];
                const nextLine = lines[i + 1].trim();
                const ratingMatch = nextLine.match(/\*\*Rating:\*\*\s*(.+)/);
                
                if (ratingMatch) {
                    let rating = ratingMatch[1].trim();
                    // Convert text ratings to numbers if needed
                    if (rating === 'N/A' || rating === "Don't Remember") {
                        rating = 'N/A';
                    } else {
                        rating = parseInt(rating) || rating;
                    }
                    extractedRatings[title] = rating;
                }
            }
        }
    }
    
    if (Object.keys(extractedRatings).length > 0) {
        Object.assign(ratings, extractedRatings);
        displayResults();
        generatePrompt();
        alert(`Successfully imported ${Object.keys(extractedRatings).length} rated titles from text file.`);
    } else {
        alert('No valid ratings found in the text file. Please check the format.');
    }
}

function processRatingsCSV(text) {
    const lines = text.split('\n');
    const extractedRatings = {};
    
    // Skip header row
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line === '') continue;
        
        let title, rating;
        
        // Handle quoted titles with commas
        if (line.startsWith('"')) {
            const firstQuoteIndex = line.indexOf('"') + 1;
            const secondQuoteIndex = line.indexOf('"', firstQuoteIndex);
            if (secondQuoteIndex !== -1) {
                title = line.substring(firstQuoteIndex, secondQuoteIndex);
                const remainingLine = line.substring(secondQuoteIndex + 1);
                rating = remainingLine.split(',')[1]?.trim();
            }
        } else {
            const parts = line.split(',');
            title = parts[0]?.trim();
            rating = parts[1]?.trim();
        }
        
        if (title && rating) {
            // Convert rating to appropriate format
            if (rating === 'N/A' || rating === "Don't Remember") {
                rating = 'N/A';
            } else {
                rating = parseInt(rating) || rating;
            }
            extractedRatings[title] = rating;
        }
    }
    
    if (Object.keys(extractedRatings).length > 0) {
        Object.assign(ratings, extractedRatings);
        displayResults();
        generatePrompt();
        alert(`Successfully imported ${Object.keys(extractedRatings).length} rated titles from CSV file.`);
    } else {
        alert('No valid ratings found in the CSV file.');
    }
}

function processNetflixCSV(text) {
    const lines = text.split('\n');
    const titlesSet = new Set();
    
    // Simple parsing, assuming 'Title' is the first column in the CSV as per the file snippet
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim() === '') continue;
        
        let title;
        // Handle titles with commas inside quotes, which is common in Netflix history
        if (line.startsWith('"')) {
            const firstQuoteIndex = line.indexOf('"') + 1;
            const secondQuoteIndex = line.indexOf('"', firstQuoteIndex);
            if (secondQuoteIndex !== -1) {
                title = line.substring(firstQuoteIndex, secondQuoteIndex);
            }
        } else {
            title = line.split(',')[0].trim();
        }

        if (title) {
            const cleanTitle = getCleanTitle(title);
            if (cleanTitle) {
                titlesSet.add(cleanTitle);
            }
        }
    }
    
    uniqueTitles = Array.from(titlesSet);
    currentTitleIndex = 0;
    
    if (uniqueTitles.length > 0) {
        document.getElementById('modal-overlay').style.display = 'flex';
        showCurrentTitle();
        saveState();
    } else {
        alert('No titles found in the CSV file.');
    }
}

function getCleanTitle(title) {
    const colonIndex = title.indexOf(':');
    if (colonIndex !== -1) {
        return title.substring(0, colonIndex).trim();
    }
    return title.trim();
}

function showCurrentTitle() {
    if (currentTitleIndex < uniqueTitles.length) {
        const title = uniqueTitles[currentTitleIndex];
        document.getElementById('modal-title').textContent = title;
        document.getElementById('progress-counter').textContent = `${currentTitleIndex + 1} of ${uniqueTitles.length}`;
    } else {
        finishRating();
    }
}

function handleRatingClick(event) {
    const button = event.target.closest('.rating-button');
    if (button) {
        const title = uniqueTitles[currentTitleIndex];
        const rating = button.dataset.rating;
        const numericRating = ratingMap[rating];
        ratings[title] = numericRating;
        
        currentTitleIndex++;
        saveState();
        showCurrentTitle();
    }
}

function finishRating() {
    document.getElementById('modal-overlay').style.display = 'none';
    displayResults();
    generatePrompt();
    // Clear the session storage since we're done
    sessionStorage.removeItem('netflixRaterState');
}

function displayResults() {
    const resultsSection = document.getElementById('results-section');
    const tableBody = resultsSection.querySelector('tbody');
    tableBody.innerHTML = '';
    
    const ratedTitles = Object.keys(ratings);
    ratedTitles.forEach(title => {
        const row = document.createElement('tr');
        row.innerHTML = `<td>${title}</td><td>${ratings[title]}</td>`;
        tableBody.appendChild(row);
    });
    
    resultsSection.style.display = 'block';
}

function generatePrompt() {
    const promptSection = document.getElementById('prompt-section');
    const promptTextarea = document.getElementById('search-prompt');
    
    const totalTitles = Object.keys(ratings).length;
    const sources = [];
    
    // Determine data sources
    if (uniqueTitles.length > 0) {
        sources.push('Netflix viewing history');
    }
    if (totalTitles > uniqueTitles.length || uniqueTitles.length === 0) {
        sources.push('imported ratings files');
    }
    
    let promptContent = `**MASTER ENTERTAINMENT ANALYSIS REQUEST**

Based on the comprehensive list of ${totalTitles} shows and movies with their corresponding ratings compiled from multiple sources (${sources.join(', ')}), please perform the following comprehensive analysis tasks:

**üìä MY COMPLETE RATINGS DATABASE:**
`;
    
    // Group ratings by score for better organization
    const ratingGroups = {
        5: [], 4: [], 3: [], 2: [], 1: [], 'N/A': []
    };
    
    Object.keys(ratings).forEach(title => {
        const rating = ratings[title];
        if (ratingGroups[rating]) {
            ratingGroups[rating].push(title);
        }
    });
    
    // Add grouped ratings to prompt
    Object.keys(ratingGroups).forEach(rating => {
        if (ratingGroups[rating].length > 0) {
            const ratingLabel = rating === 'N/A' ? 'Not Rated/Don\'t Remember' : 
                                rating === '5' ? 'Amazing (5/5)' :
                                rating === '4' ? 'Good (4/5)' :
                                rating === '3' ? 'OK (3/5)' :
                                rating === '2' ? 'Kinda Sucked (2/5)' : 'Hated It (1/5)';
            
            promptContent += `\n**${ratingLabel}:**\n`;
            ratingGroups[rating].forEach(title => {
                promptContent += `- "${title}"\n`;
            });
        }
    });
    
    promptContent += `

**üéØ COMPREHENSIVE ANALYSIS TASKS:**

**Task 1: Creative Team Deep Dive**
For each title in my ratings database:
- Identify primary directors, writers, showrunners, and key producers
- Cross-reference my ratings with their other works
- Create a "creator preference matrix" showing which creative teams I consistently rate highly

**Task 2: Genre & Theme Pattern Analysis**
- Analyze my ratings across different genres, themes, and content types
- Identify my "sweet spots" (genres/themes I consistently rate 4-5)
- Note any surprising patterns or contradictions in my preferences

**Task 3: Grassroots Community Research**
For each highly-rated title (4-5 stars) and their creative teams:
- Search dedicated fan communities (Reddit, Discord, specialized forums)
- Mine YouTube comments, fan channels, and social media discussions
- Identify grassroots recommendations from genuine fans (not algorithmic suggestions)

**Task 4: Cross-Platform Content Discovery**
- Search across ALL streaming platforms (Netflix, Hulu, Disney+, HBO Max, Amazon Prime, Apple TV+, Paramount+, etc.)
- Include international content and smaller streaming services
- Consider theatrical releases and limited series

**Task 5: Advanced Recommendation Engine**
Create a prioritized list of 100+ new titles using this methodology:
1. **Correlation Scoring**: Match recommendations to my highest-rated content
2. **Creator Tracking**: Prioritize new works by my favorite creative teams
3. **Community Validation**: Weight recommendations by grassroots fan enthusiasm
4. **Availability Mapping**: List current streaming platform(s) for each suggestion
5. **Freshness Factor**: Include both hidden gems and recent releases

**Task 6: Meta-Analysis & Insights**
- Identify blind spots in my viewing (unexplored genres I might enjoy)
- Suggest "gateway content" to ease into new genres based on my preferences
- Highlight any cult classics or critically acclaimed works I've missed
- Note any franchise/universe content I should explore based on my ratings

**üìã FINAL OUTPUT FORMAT:**

**SECTION A: My Entertainment Profile**
- Top-rated genres and themes
- Favorite creative teams (directors, writers, etc.)
- Content patterns and preferences

**SECTION B: Priority Recommendations (Ranked 1-100+)**
For each recommendation, include:
- Title and brief description
- Streaming platform(s) and availability
- Connection to my highly-rated content
- Fan community enthusiasm score
- Why it matches my taste profile

**SECTION C: Strategic Viewing Suggestions**
- Genre expansion opportunities
- Franchise/universe deep-dives
- Hidden gems likely to become new favorites
- "Must-watch" content I've surprisingly missed

**üé¨ GOAL:** Create the most personalized, comprehensive entertainment recommendation system based on ${totalTitles} data points of my actual viewing preferences, validated by genuine fan communities rather than algorithmic suggestions.

**üìà DATA SOURCES TO PRIORITIZE:**
- Organic fan discussions and recommendations
- Creator filmographies and upcoming projects  
- Cross-platform content availability
- Community-driven "hidden gems" lists
- Genre-specific enthusiast communities

Please provide detailed, actionable recommendations that go beyond mainstream suggestions to uncover truly personalized entertainment discoveries.`;

    promptTextarea.value = promptContent;
    
    // Show the prompt section
    promptSection.style.display = 'block';
}

function copyPrompt() {
    const promptTextarea = document.getElementById('search-prompt');
    promptTextarea.select();
    promptTextarea.setSelectionRange(0, 99999); // For mobile devices
    
    try {
        document.execCommand('copy');
        const copyButton = document.querySelector('.copy-button');
        const originalText = copyButton.textContent;
        copyButton.textContent = 'Copied!';
        copyButton.style.backgroundColor = '#218838';
        
        setTimeout(() => {
            copyButton.textContent = originalText;
            copyButton.style.backgroundColor = '#28a745';
        }, 2000);
    } catch (err) {
        alert('Failed to copy. Please select the text and copy manually.');
    }
}

function toggleConverter() {
    const converterSection = document.getElementById('text-converter-section');
    if (converterSection.style.display === 'none') {
        converterSection.style.display = 'block';
    } else {
        converterSection.style.display = 'none';
    }
}

function convertTextToCSV() {
    const textInput = document.getElementById('text-input');
    const text = textInput.value.trim();
    
    if (!text) {
        alert('Please paste your ratings text first.');
        return;
    }
    
    const lines = text.split('\n');
    let csvContent = "Title,Rating\n";
    const convertedRatings = {};
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Look for title line in standard format
        if (line.includes('**Title:**')) {
            const titleMatch = line.match(/\*\*Title:\*\*\s*"([^"]+)"/);
            if (titleMatch && i + 1 < lines.length) {
                const title = titleMatch[1];
                const nextLine = lines[i + 1].trim();
                const ratingMatch = nextLine.match(/\*\*Rating:\*\*\s*(.+)/);
                
                if (ratingMatch) {
                    let rating = ratingMatch[1].trim();
                    csvContent += `"${title}",${rating}\n`;
                    convertedRatings[title] = rating === 'N/A' ? 'N/A' : (parseInt(rating) || rating);
                }
            }
        }
        // Handle other formats
        else if (line.includes(':') && !line.includes('**')) {
            const parts = line.split(':');
            if (parts.length >= 2) {
                const title = parts[0].trim().replace(/^["'\-\s*]+|["'\s*]+$/g, '');
                const rating = parts.slice(1).join(':').trim();
                if (title && rating) {
                    csvContent += `"${title}",${rating}\n`;
                    convertedRatings[title] = rating === 'N/A' ? 'N/A' : (parseInt(rating) || rating);
                }
            }
        }
        else if (line.includes(',') && !line.includes('**')) {
            const parts = line.split(',');
            if (parts.length >= 2) {
                const title = parts[0].trim().replace(/^["'\-\s*]+|["'\s*]+$/g, '');
                const rating = parts.slice(1).join(',').trim();
                if (title && rating) {
                    csvContent += `"${title}",${rating}\n`;
                    convertedRatings[title] = rating === 'N/A' ? 'N/A' : (parseInt(rating) || rating);
                }
            }
        }
    }
    
    if (csvContent === "Title,Rating\n") {
        alert('No valid ratings found. Please check your text format.');
        return;
    }
    
    // Add converted ratings to the main ratings object
    Object.assign(ratings, convertedRatings);
    
    // Download the CSV
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", "converted_ratings.csv");
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Update display and generate master prompt
    displayResults();
    generatePrompt();
    
    // Show success message
    const convertedCount = Object.keys(convertedRatings).length;
    const totalCount = Object.keys(ratings).length;
    alert(`Successfully converted ${convertedCount} ratings to CSV and integrated into master list!\n\nTotal titles now: ${totalCount}`);
    
    // Hide the converter after successful conversion
    toggleConverter();
}

async function pasteFromClipboard() {
    const textInput = document.getElementById('text-input');
    
    try {
        // Try to use the modern clipboard API first
        if (navigator.clipboard && navigator.clipboard.readText) {
            const clipboardText = await navigator.clipboard.readText();
            textInput.value = clipboardText;
            updateCharacterCount();
            
            // Show success feedback
            const pasteButton = event.target;
            const originalText = pasteButton.textContent;
            pasteButton.textContent = 'üìã Pasted!';
            pasteButton.style.backgroundColor = '#138496';
            
            setTimeout(() => {
                pasteButton.textContent = originalText;
                pasteButton.style.backgroundColor = '#17a2b8';
            }, 1500);
        } else {
            // Fallback for older browsers
            textInput.focus();
            document.execCommand('paste');
            setTimeout(updateCharacterCount, 100);
            alert('Text pasted! If nothing appeared, try using Ctrl+V (Windows) or Cmd+V (Mac) manually.');
        }
    } catch (err) {
        // If clipboard access is denied or fails
        textInput.focus();
        alert('Unable to access clipboard automatically. Please use Ctrl+V (Windows) or Cmd+V (Mac) to paste your text.');
    }
}

function clearTextInput() {
    const textInput = document.getElementById('text-input');
    textInput.value = '';
    textInput.focus();
    updateCharacterCount();
    
    // Show feedback
    const clearButton = event.target;
    const originalText = clearButton.textContent;
    clearButton.textContent = 'üóëÔ∏è Cleared!';
    clearButton.style.backgroundColor = '#e0a800';
    
    setTimeout(() => {
        clearButton.textContent = originalText;
        clearButton.style.backgroundColor = '#ffc107';
    }, 1500);
}

function updateCharacterCount() {
    const textInput = document.getElementById('text-input');
    const charCounter = document.getElementById('char-counter');
    const length = textInput.value.length;
    
    if (length === 0) {
        charCounter.textContent = '0 characters';
    } else if (length < 1000) {
        charCounter.textContent = `${length} characters`;
    } else if (length < 1000000) {
        charCounter.textContent = `${length} characters (${(length/1000).toFixed(1)}K)`;
    } else {
        charCounter.textContent = `${length} characters (${(length/1000000).toFixed(1)}M)`;
    }
    
    // Change color based on content length
    if (length === 0) {
        charCounter.style.color = '#666';
    } else if (length < 1000) {
        charCounter.style.color = '#28a745';
    } else if (length < 10000) {
        charCounter.style.color = '#ffc107';
    } else {
        charCounter.style.color = '#dc3545';
    }
}

function autoFormatText() {
    const textInput = document.getElementById('text-input');
    let text = textInput.value.trim();
    
    if (!text) {
        alert('Please paste some text first to auto-format.');
        return;
    }
    
    // Try to detect and convert different formats to the standard format
    const lines = text.split('\n');
    let formattedText = '';
    let formatDetected = false;
    
    for (let line of lines) {
        line = line.trim();
        if (!line) continue;
        
        // Format: "Title: Rating" or "Title,Rating"
        if (line.includes(':') && !line.includes('**Title:**')) {
            const parts = line.split(':');
            if (parts.length >= 2) {
                const title = parts[0].trim().replace(/^["']|["']$/g, '');
                const rating = parts.slice(1).join(':').trim();
                formattedText += `- **Title:** "${title}"\n**Rating:** ${rating}\n`;
                formatDetected = true;
            }
        }
        // Format: "Title,Rating"
        else if (line.includes(',') && !line.includes('**Title:**')) {
            const parts = line.split(',');
            if (parts.length >= 2) {
                const title = parts[0].trim().replace(/^["']|["']$/g, '');
                const rating = parts.slice(1).join(',').trim();
                formattedText += `- **Title:** "${title}"\n**Rating:** ${rating}\n`;
                formatDetected = true;
            }
        }
        // Already in correct format or unrecognized - keep as is
        else {
            formattedText += line + '\n';
        }
    }
    
    if (formatDetected) {
        textInput.value = formattedText.trim();
        updateCharacterCount();
        
        // Show success feedback
        const formatButton = event.target;
        const originalText = formatButton.textContent;
        formatButton.textContent = '‚ú® Formatted!';
        formatButton.style.backgroundColor = '#1e7e34';
        
        setTimeout(() => {
            formatButton.textContent = originalText;
            formatButton.style.backgroundColor = '#28a745';
        }, 2000);
    } else {
        alert('No formatting needed - text appears to already be in the correct format or no recognizable patterns found.');
    }
}

function downloadCSV() {
    let csvContent = "Title,Rating\n";
    
    Object.keys(ratings).forEach(title => {
        const rating = ratings[title];
        csvContent += `"${title}",${rating}\n`;
    });
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", "netflix_ratings.csv");
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}
</script>

</body>
</html>
