<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netflix Viewing History Rater</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        .container {
            width: 90%;
            max-width: 900px;
            margin: 20px auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        h1 {
            color: #E50914;
            text-align: center;
        }
        p {
            text-align: center;
        }
        .file-input-container {
            text-align: center;
            margin-bottom: 20px;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 40px 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 90%;
            min-height: 250px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .title-name {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .rating-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        .rating-button {
            padding: 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .rating-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .rating-button.hated { background-color: #d9534f; }
        .rating-button.sucked { background-color: #f0ad4e; }
        .rating-button.ok { background-color: #5bc0de; }
        .rating-button.good { background-color: #5cb85c; }
        .rating-button.amazing { background-color: #0275d8; }
        .rating-button.dont-remember { background-color: #6c757d; }
        .results-section {
            margin-top: 40px;
            border-top: 2px solid #ccc;
            padding-top: 20px;
            display: none;
        }
        #results-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        #results-table th, #results-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        #results-table th {
            background-color: #f2f2f2;
        }
        .download-button {
            padding: 12px 24px;
            background-color: #E50914;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            display: block;
            margin: 20px auto;
        }
        .prompt-textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
        }
        .copy-button {
            padding: 12px 24px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px auto;
            display: block;
        }
        .copy-button:hover {
            background-color: #218838;
        }
        .enough-button {
            padding: 12px 24px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px;
            font-size: 0.9em;
        }
        .enough-button:hover {
            background-color: #5a6268;
        }
        .modal-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .progress-counter {
            font-size: 0.9em;
            color: #666;
        }
        /* Mobile responsiveness */
        @media (max-width: 600px) {
            .container {
                width: 95%;
            }
            .modal-content {
                padding: 20px;
            }
            .rating-buttons {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Netflix Viewing History Rater</h1>
    <div class="file-input-container">
        <p>Upload your Netflix viewing history CSV file to rate your shows and movies, or upload existing ratings files.</p>
        <input type="file" id="csvFile" accept=".csv,.txt" />
        <p style="margin-top: 10px;"><em>Supports: Netflix CSV files, TXT files with ratings, or CSV exports from previous sessions</em></p>
    </div>

    <div class="results-section" id="text-converter-section" style="display: none;">
        <h2>Text to CSV Converter</h2>
        <p>Paste your ratings in the format below and convert them to CSV for download:</p>
        <textarea class="prompt-textarea" id="text-input" placeholder='- **Title:** "Movie Name"
**Rating:** 5
- **Title:** "Another Movie"
**Rating:** 3'></textarea>
        <button class="copy-button" onclick="convertTextToCSV()">Convert to CSV & Download</button>
        <button class="copy-button" style="background-color: #6c757d; margin-left: 10px;" onclick="toggleConverter()">Close Converter</button>
    </div>

    <div style="text-align: center; margin: 20px 0;">
        <button class="copy-button" style="background-color: #17a2b8;" onclick="toggleConverter()">Show Text to CSV Converter</button>
    </div>

    <div class="modal-overlay" id="modal-overlay">
        <div class="modal-content">
            <div class="modal-controls">
                <div class="progress-counter" id="progress-counter"></div>
                <button class="enough-button" onclick="finishRating()">That's Enough</button>
            </div>
            <div id="modal-title" class="title-name"></div>
            <div id="modal-buttons" class="rating-buttons">
                <button class="rating-button hated" data-rating="Hated it">Hated it</button>
                <button class="rating-button sucked" data-rating="Kinda Sucked">Kinda Sucked</button>
                <button class="rating-button ok" data-rating="OK">OK</button>
                <button class="rating-button good" data-rating="Good">Good</button>
                <button class="rating-button amazing" data-rating="Amazing">Amazing</button>
                <button class="rating-button dont-remember" data-rating="Don't Remember">Don't Remember</button>
            </div>
        </div>
    </div>

    <div class="results-section" id="results-section">
        <h2>Your Ratings</h2>
        <p>Your ratings have been captured. You can download the results as a CSV file below.</p>
        <table id="results-table">
            <thead>
                <tr>
                    <th>Title</th>
                    <th>Rating</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
        <button class="download-button" onclick="downloadCSV()">Download Ratings CSV</button>
    </div>

    <div class="results-section" id="prompt-section">
        <h2>Custom Search Prompt</h2>
        <p>This is a custom prompt you can use for further analysis with an AI.</p>
        <textarea class="prompt-textarea" id="search-prompt" readonly></textarea>
        <button class="copy-button" onclick="copyPrompt()">Copy Prompt to Clipboard</button>
    </div>
</div>

<script>
document.getElementById('csvFile').addEventListener('change', handleFileSelect);
document.getElementById('modal-buttons').addEventListener('click', handleRatingClick);

// Load state from localStorage on page load
window.addEventListener('load', loadState);
window.addEventListener('beforeunload', saveState);

const ratings = {};
let uniqueTitles = [];
let currentTitleIndex = 0;

const ratingMap = {
    'Hated it': 1,
    'Kinda Sucked': 2,
    'OK': 3,
    'Good': 4,
    'Amazing': 5,
    "Don't Remember": 'N/A'
};

function saveState() {
    const state = {
        ratings: ratings,
        uniqueTitles: uniqueTitles,
        currentTitleIndex: currentTitleIndex,
        timestamp: Date.now()
    };
    sessionStorage.setItem('netflixRaterState', JSON.stringify(state));
}

function loadState() {
    const savedState = sessionStorage.getItem('netflixRaterState');
    if (savedState) {
        try {
            const state = JSON.parse(savedState);
            // Only restore if it's less than 1 hour old
            if (Date.now() - state.timestamp < 3600000) {
                Object.assign(ratings, state.ratings);
                uniqueTitles = state.uniqueTitles || [];
                currentTitleIndex = state.currentTitleIndex || 0;
                
                if (uniqueTitles.length > 0 && currentTitleIndex < uniqueTitles.length) {
                    if (confirm('It looks like you were in the middle of rating your Netflix titles. Would you like to continue where you left off?')) {
                        document.getElementById('modal-overlay').style.display = 'flex';
                        showCurrentTitle();
                        return;
                    }
                } else if (Object.keys(ratings).length > 0) {
                    // They had completed rating, show results
                    displayResults();
                    generatePrompt();
                }
            }
        } catch (e) {
            console.log('Could not restore previous state');
        }
    }
}

function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file) {
        // Clear previous state when uploading new file
        sessionStorage.removeItem('netflixRaterState');
        Object.keys(ratings).forEach(key => delete ratings[key]);
        uniqueTitles = [];
        currentTitleIndex = 0;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            if (file.name.toLowerCase().endsWith('.txt')) {
                processTXT(e.target.result);
            } else if (file.name.toLowerCase().endsWith('.csv')) {
                // Check if it's a ratings CSV (has Title,Rating format) or Netflix history CSV
                const content = e.target.result;
                const lines = content.split('\n');
                if (lines[0] && lines[0].toLowerCase().includes('title') && lines[0].toLowerCase().includes('rating')) {
                    processRatingsCSV(content);
                } else {
                    processNetflixCSV(content);
                }
            }
        };
        reader.readAsText(file);
    }
}

function processTXT(text) {
    const lines = text.split('\n');
    const extractedRatings = {};
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Look for title line
        if (line.includes('**Title:**')) {
            const titleMatch = line.match(/\*\*Title:\*\*\s*"([^"]+)"/);
            if (titleMatch && i + 1 < lines.length) {
                const title = titleMatch[1];
                const nextLine = lines[i + 1].trim();
                const ratingMatch = nextLine.match(/\*\*Rating:\*\*\s*(.+)/);
                
                if (ratingMatch) {
                    let rating = ratingMatch[1].trim();
                    // Convert text ratings to numbers if needed
                    if (rating === 'N/A' || rating === "Don't Remember") {
                        rating = 'N/A';
                    } else {
                        rating = parseInt(rating) || rating;
                    }
                    extractedRatings[title] = rating;
                }
            }
        }
    }
    
    if (Object.keys(extractedRatings).length > 0) {
        Object.assign(ratings, extractedRatings);
        displayResults();
        generatePrompt();
        alert(`Successfully imported ${Object.keys(extractedRatings).length} rated titles from text file.`);
    } else {
        alert('No valid ratings found in the text file. Please check the format.');
    }
}

function processRatingsCSV(text) {
    const lines = text.split('\n');
    const extractedRatings = {};
    
    // Skip header row
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line === '') continue;
        
        let title, rating;
        
        // Handle quoted titles with commas
        if (line.startsWith('"')) {
            const firstQuoteIndex = line.indexOf('"') + 1;
            const secondQuoteIndex = line.indexOf('"', firstQuoteIndex);
            if (secondQuoteIndex !== -1) {
                title = line.substring(firstQuoteIndex, secondQuoteIndex);
                const remainingLine = line.substring(secondQuoteIndex + 1);
                rating = remainingLine.split(',')[1]?.trim();
            }
        } else {
            const parts = line.split(',');
            title = parts[0]?.trim();
            rating = parts[1]?.trim();
        }
        
        if (title && rating) {
            // Convert rating to appropriate format
            if (rating === 'N/A' || rating === "Don't Remember") {
                rating = 'N/A';
            } else {
                rating = parseInt(rating) || rating;
            }
            extractedRatings[title] = rating;
        }
    }
    
    if (Object.keys(extractedRatings).length > 0) {
        Object.assign(ratings, extractedRatings);
        displayResults();
        generatePrompt();
        alert(`Successfully imported ${Object.keys(extractedRatings).length} rated titles from CSV file.`);
    } else {
        alert('No valid ratings found in the CSV file.');
    }
}

function processNetflixCSV(text) {
    const lines = text.split('\n');
    const titlesSet = new Set();
    
    // Simple parsing, assuming 'Title' is the first column in the CSV as per the file snippet
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim() === '') continue;
        
        let title;
        // Handle titles with commas inside quotes, which is common in Netflix history
        if (line.startsWith('"')) {
            const firstQuoteIndex = line.indexOf('"') + 1;
            const secondQuoteIndex = line.indexOf('"', firstQuoteIndex);
            if (secondQuoteIndex !== -1) {
                title = line.substring(firstQuoteIndex, secondQuoteIndex);
            }
        } else {
            title = line.split(',')[0].trim();
        }

        if (title) {
            const cleanTitle = getCleanTitle(title);
            if (cleanTitle) {
                titlesSet.add(cleanTitle);
            }
        }
    }
    
    uniqueTitles = Array.from(titlesSet);
    currentTitleIndex = 0;
    
    if (uniqueTitles.length > 0) {
        document.getElementById('modal-overlay').style.display = 'flex';
        showCurrentTitle();
        saveState();
    } else {
        alert('No titles found in the CSV file.');
    }
}

function getCleanTitle(title) {
    const colonIndex = title.indexOf(':');
    if (colonIndex !== -1) {
        return title.substring(0, colonIndex).trim();
    }
    return title.trim();
}

function showCurrentTitle() {
    if (currentTitleIndex < uniqueTitles.length) {
        const title = uniqueTitles[currentTitleIndex];
        document.getElementById('modal-title').textContent = title;
        document.getElementById('progress-counter').textContent = `${currentTitleIndex + 1} of ${uniqueTitles.length}`;
    } else {
        finishRating();
    }
}

function handleRatingClick(event) {
    const button = event.target.closest('.rating-button');
    if (button) {
        const title = uniqueTitles[currentTitleIndex];
        const rating = button.dataset.rating;
        const numericRating = ratingMap[rating];
        ratings[title] = numericRating;
        
        currentTitleIndex++;
        saveState();
        showCurrentTitle();
    }
}

function finishRating() {
    document.getElementById('modal-overlay').style.display = 'none';
    displayResults();
    generatePrompt();
    // Clear the session storage since we're done
    sessionStorage.removeItem('netflixRaterState');
}

function displayResults() {
    const resultsSection = document.getElementById('results-section');
    const tableBody = resultsSection.querySelector('tbody');
    tableBody.innerHTML = '';
    
    const ratedTitles = Object.keys(ratings);
    ratedTitles.forEach(title => {
        const row = document.createElement('tr');
        row.innerHTML = `<td>${title}</td><td>${ratings[title]}</td>`;
        tableBody.appendChild(row);
    });
    
    resultsSection.style.display = 'block';
}

function generatePrompt() {
    const promptSection = document.getElementById('prompt-section');
    const promptTextarea = document.getElementById('search-prompt');
    let promptContent = "Based on the following list of shows and movies with their corresponding ratings, please perform the following tasks:\n\n";
    
    Object.keys(ratings).forEach(title => {
        const rating = ratings[title];
        promptContent += `- **Title:** "${title}"\n  **Rating:** ${rating}\n`;
    });
    
    promptContent += `
\n**Task 1: Director and Writer Identification**
For each title in the list, search for its primary writer and director. Add their names to the corresponding title entry.

**Task 2: Grassroots Fan Discussion Analysis**
For each title, and where possible, for each identified writer and director, search for dedicated fan communities on platforms like Reddit (subreddits), YouTube channels, and social media groups.

**Task 3: Find Similar Recommendations**
Within the comments and discussions of these fan communities, find grassroots recommendations. These are mentions of other shows or movies that fans compare to the listed titles or to other works by the same writer or director.
    
**Task 4: Data Consolidation and Prioritization**
1.  Harvest a list of the top 100 most mentioned new titles.
2.  For each suggested title, identify and list the streaming platform(s) where it can be watched.
3.  Count the number of times each suggested title is mentioned in the discussions.
4.  Ensure that no suggested title is already present in my original Netflix viewing history list.
5.  Sort the final list of suggestions based on how they correlate to my original ratings. For example, suggestions related to titles I rated "5" should be at the top, followed by "4," "3," and so on.

**Output:**
Present the results as a well-structured list, including the suggested title, its streaming platform(s), the mention count, and a brief note on which of my original titles or creators it was linked to.
`;
    promptTextarea.value = promptContent;
    
    // Show the prompt section only after all ratings are complete
    promptSection.style.display = 'block';
}

function copyPrompt() {
    const promptTextarea = document.getElementById('search-prompt');
    promptTextarea.select();
    promptTextarea.setSelectionRange(0, 99999); // For mobile devices
    
    try {
        document.execCommand('copy');
        const copyButton = document.querySelector('.copy-button');
        const originalText = copyButton.textContent;
        copyButton.textContent = 'Copied!';
        copyButton.style.backgroundColor = '#218838';
        
        setTimeout(() => {
            copyButton.textContent = originalText;
            copyButton.style.backgroundColor = '#28a745';
        }, 2000);
    } catch (err) {
        alert('Failed to copy. Please select the text and copy manually.');
    }
}

function downloadCSV() {
    let csvContent = "Title,Rating\n";
    
    Object.keys(ratings).forEach(title => {
        const rating = ratings[title];
        csvContent += `"${title}",${rating}\n`;
    });
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", "netflix_ratings.csv");
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}
</script>

</body>
</html>
